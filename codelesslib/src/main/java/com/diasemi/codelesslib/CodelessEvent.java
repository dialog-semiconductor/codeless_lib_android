/*
 **********************************************************************************
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2020-2024 Renesas Electronics Corporation and/or its affiliates
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Renesas nor the names of its contributors may be
 *    used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY RENESAS "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL RENESAS OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 **********************************************************************************
 */

package com.diasemi.codelesslib;

import android.bluetooth.BluetoothDevice;
import android.net.Uri;

import com.diasemi.codelesslib.command.AdcReadCommand;
import com.diasemi.codelesslib.command.AdvertisingDataCommand;
import com.diasemi.codelesslib.command.AdvertisingResponseCommand;
import com.diasemi.codelesslib.command.BasicCommand;
import com.diasemi.codelesslib.command.BatteryLevelCommand;
import com.diasemi.codelesslib.command.BaudRateCommand;
import com.diasemi.codelesslib.command.BinEscCommand;
import com.diasemi.codelesslib.command.BluetoothAddressCommand;
import com.diasemi.codelesslib.command.BondingEntryClearCommand;
import com.diasemi.codelesslib.command.BondingEntryStatusCommand;
import com.diasemi.codelesslib.command.BondingEntryTransferCommand;
import com.diasemi.codelesslib.command.CmdGetCommand;
import com.diasemi.codelesslib.command.CodelessCommand;
import com.diasemi.codelesslib.command.ConnectionParametersCommand;
import com.diasemi.codelesslib.command.DataLengthEnableCommand;
import com.diasemi.codelesslib.command.DeviceInformationCommand;
import com.diasemi.codelesslib.command.EventConfigCommand;
import com.diasemi.codelesslib.command.EventHandlerCommand;
import com.diasemi.codelesslib.command.FlowControlCommand;
import com.diasemi.codelesslib.command.GapConnectCommand;
import com.diasemi.codelesslib.command.GapDisconnectCommand;
import com.diasemi.codelesslib.command.GapScanCommand;
import com.diasemi.codelesslib.command.GapStatusCommand;
import com.diasemi.codelesslib.command.HeartbeatCommand;
import com.diasemi.codelesslib.command.HostSleepCommand;
import com.diasemi.codelesslib.command.I2cConfigCommand;
import com.diasemi.codelesslib.command.I2cReadCommand;
import com.diasemi.codelesslib.command.I2cScanCommand;
import com.diasemi.codelesslib.command.IoConfigCommand;
import com.diasemi.codelesslib.command.IoStatusCommand;
import com.diasemi.codelesslib.command.MaxMtuCommand;
import com.diasemi.codelesslib.command.MemStoreCommand;
import com.diasemi.codelesslib.command.PinCodeCommand;
import com.diasemi.codelesslib.command.PowerLevelConfigCommand;
import com.diasemi.codelesslib.command.PulseGenerationCommand;
import com.diasemi.codelesslib.command.RandomNumberCommand;
import com.diasemi.codelesslib.command.RssiCommand;
import com.diasemi.codelesslib.command.SecurityModeCommand;
import com.diasemi.codelesslib.command.SpiConfigCommand;
import com.diasemi.codelesslib.command.SpiReadCommand;
import com.diasemi.codelesslib.command.SpiTransferCommand;
import com.diasemi.codelesslib.command.UartEchoCommand;
import com.diasemi.codelesslib.command.UartPrintCommand;
import com.diasemi.codelesslib.dsps.DspsFileReceive;
import com.diasemi.codelesslib.dsps.DspsFileSend;
import com.diasemi.codelesslib.dsps.DspsPeriodicSend;

import java.io.File;
import java.util.ArrayList;
import java.util.UUID;

/**
 * Contains event classes for all possible events that can be generated by the CodeLess library.
 * <p>
 * Events are generated as a result of BLE operations (for example, connection/disconnection),
 * CodeLess operations, AT commands results, or DSPS operations. Each event object contains
 * information about the relevant event.
 * <h2>Usage</h2>
 * Events are sent using the <a href="https://github.com/greenrobot/EventBus">EventBus</a> library.
 * <ul>
 * <li> Include the EventBus library in your app's <code>build.gradle</code>:
 * <blockquote><pre>
 * implementation 'org.greenrobot:eventbus:3.3.1'</pre></blockquote>
 * </li>
 * <li> Subscribe to the required events from your app code.
 * <blockquote><pre>
 * &#64;Subscribe(threadMode = ThreadMode.MAIN_ORDERED)
 * public void onPrint(CodelessEvent.Print event) {
 *     if (manager != event.manager)
 *         return;
 *     Toast.makeText(this, event.text, Toast.LENGTH_SHORT).show();
 * }</pre></blockquote>
 * <code>ThreadMode.MAIN_ORDERED</code> is the recommended subscription mode.
 * </li>
 * <li> Register your app code to receive events. For example, you can register an Activity or Fragment.
 * <blockquote><pre>
 * public void onCreate(Bundle savedInstanceState) {
 *     ...
 *     EventBus.getDefault().register(this);
 *     ...
 * }</pre></blockquote>
 * </li>
 * </ul>
 * @see CodelessManager
 * @see CodelessScanner
 * @see <a href="https://lpccs-docs.renesas.com/UM-140-DA145x-CodeLess/index.html">AT commands documentation</a>
 */
public class CodelessEvent {

    /** Base class for {@link CodelessScanner scanner} events. */
    private static class ScanEvent {
        /** The {@link CodelessScanner scanner} that generated the event. */
        public CodelessScanner scanner;

        public ScanEvent(CodelessScanner scanner) {
            this.scanner = scanner;
        }
    }

    /** Event generated when scanning has started. */
    public static class ScanStart extends ScanEvent {
        public ScanStart(CodelessScanner scanner) {
            super(scanner);
        }
    }

    /** Event generated when scanning has stopped. */
    public static class ScanStop extends ScanEvent {
        public ScanStop(CodelessScanner scanner) {
            super(scanner);
        }
    }

    /**
     * Event generated when scanning needs to be restarted.
     * <p>
     * In case scanning cannot be started due to missing requirements (for example, missing
     * permissions), the library can initiate the required user action to fulfill the
     * requirements. After the user action is complete, this event is sent.
     * The app should start the scan again when this event is received.
     */
    public static class ScanRestart extends ScanEvent {
        public ScanRestart(CodelessScanner scanner) {
            super(scanner);
        }
    }

    /** Event generated when a device is found during scanning. */
    public static class ScanResult extends ScanEvent {
        /** The found device. */
        public BluetoothDevice device;
        /** Parsed advertising data from the advertising event. */
        public CodelessScanner.AdvData advData;
        /** The RSSI of the received advertising event. */
        public int rssi;

        public ScanResult(CodelessScanner scanner, BluetoothDevice device, CodelessScanner.AdvData advData, int rssi) {
            super(scanner);
            this.device = device;
            this.advData = advData;
            this.rssi = rssi;
        }
    }

    /** Base class for {@link CodelessManager manager} events. */
    private static class Event {
        /** The {@link CodelessManager manager} that generated the event. */
        public CodelessManager manager;

        public Event(CodelessManager manager) {
            this.manager = manager;
        }
    }

    /**
     * Event generated when the connection state of the device changes.
     * <p>
     * The possible states are: disconnected, connecting, connected.
     * Use {@link CodelessManager#getState() manager.getState()} to get the current state.
     */
    public static class Connection extends Event {
        public Connection(CodelessManager manager) {
            super(manager);
        }
    }

    /** Event generated when the service discovery process is started or is complete. */
    public static class ServiceDiscovery extends Event {
        /** <code>false</code> when service discovery is started, <code>true</code> if complete. */
        public boolean complete;

        public ServiceDiscovery(CodelessManager manager, boolean complete) {
            super(manager);
            this.complete = complete;
        }
    }

    /**
     * Event generated when the connected device is ready for Codeless/DSPS operations.
     * <p> The device becomes ready after the service discovery is complete and the required notifications are enabled.
     */
    public static class Ready extends Event {
        public Ready(CodelessManager manager) {
            super(manager);
        }
    }

    // Error
    /** The operation cannot be executed, because the device is not ready. */
    public static final int ERROR_NOT_READY = 0;
    /** CodeLess/DSPS service initialization failed. */
    public static final int ERROR_INIT_SERVICES = 1;
    /** A GATT operation failed. */
    public static final int ERROR_GATT_OPERATION = 2;
    /** The operation is not allowed in the current operation mode. */
    public static final int ERROR_OPERATION_NOT_ALLOWED = 3;
    /** The command prefix is invalid. */
    public static final int ERROR_INVALID_PREFIX = 4;
    /** The command is invalid (for example, missing or invalid arguments). */
    public static final int ERROR_INVALID_COMMAND = 5;

    /** Event generated when an error occurs during manager operation. */
    public static class Error extends Event {
        /** The error {@link #ERROR_NOT_READY code}. */
        public int error;

        public Error(CodelessManager manager, int error) {
            super(manager);
            this.error = error;
        }
    }

    /** Event generated when the GAP device name characteristic is read. */
    public static class DeviceName extends Event {
        /** The GAP device name characteristic value. */
        public String name;

        public DeviceName(CodelessManager manager, String name) {
            super(manager);
            this.name = name;
        }
    }

    /** Event generated when one of the Device information characteristics is read. */
    public static class DeviceInfo extends Event {
        /** The UUID of the Device information characteristic. */
        public UUID uuid;
        /** The value of the Device information characteristic. */
        public byte[] value;
        /** The value of the Device information characteristic as string (where applicable). */
        public String info;

        public DeviceInfo(CodelessManager manager, UUID uuid, byte[] value, String info) {
            super(manager);
            this.uuid = uuid;
            this.value = value;
            this.info = info;
        }
    }

    /**
     * Event generated when the connection RSSI is read.
     * <p> Sent after {@link CodelessManager#getRssi()} is called.
     */
    public static class Rssi extends Event {
        /** The RSSI value of the connection. */
        public int rssi;

        public Rssi(CodelessManager manager, int rssi) {
            super(manager);
            this.rssi = rssi;
        }
    }

    /**
     * Event generated when the peer CodeLess device sends the <code>AT+BINREQ</code> command.
     * <p>
     * The app should call {@link CodelessManager#acceptBinaryModeRequest()}, if the request is accepted.
     * <p>
     * NOTE: This event is sent only if {@link CodelessLibConfig#HOST_BINARY_REQUEST} is enabled.
     * Otherwise the library will automatically respond with <code>AT+BINREQACK</code>, entering
     * binary mode.
     */
    public static class BinaryModeRequest extends Event {
        public BinaryModeRequest(CodelessManager manager) {
            super(manager);
        }
    }

    /** Event generated when the operation mode changes between command (CodeLess) and binary (DSPS). */
    public static class Mode extends Event {
        /** <code>true</code> if entering command mode, <code>false</code> if entering binary mode. */
        public boolean command;

        public Mode(CodelessManager manager, boolean command) {
            super(manager);
            this.command = command;
        }
    }

    /**
     * Event generated when a CodeLess communication line is processed.
     * <p> This event is sent only if {@link CodelessLibConfig#LINE_EVENTS} is enabled.
     */
    public static class CodelessLine extends Event {
        /** The CodeLess communication line. */
        public CodelessProfile.Line line;

        public CodelessLine(CodelessManager manager, CodelessProfile.Line line) {
            super(manager);
            this.line = line;
        }
    }

    /** Event generated when a CodeLess {@link CodelessScript script} has started. */
    public static class ScriptStartEvent extends Event {
        /** The script that has started. */
        public CodelessScript script;

        public ScriptStartEvent(CodelessScript script) {
            super(script.getManager());
            this.script = script;
        }
    }

    /** Event generated when a CodeLess {@link CodelessScript script} is complete. */
    public static class ScriptEndEvent extends Event {
        /** The script that is complete. */
        public CodelessScript script;
        /** <code>true</code> if an error occurred in one of the script commands, <code>false</code> otherwise. */
        public boolean error;

        public ScriptEndEvent(CodelessScript script, boolean error) {
            super(script.getManager());
            this.script = script;
            this.error = error;
        }
    }

    /** Event generated when a command that is part of a running CodeLess {@link CodelessScript script} is complete. */
    public static class ScriptCommandEvent extends Event {
        /** The script that is running. */
        public CodelessScript script;
        /** The script command that is complete. */
        public CodelessCommand command;

        public ScriptCommandEvent(CodelessScript script, CodelessCommand command) {
            super(script.getManager());
            this.script = script;
            this.command = command;
        }
    }

    /** Base class for CodeLess AT command events. */
    private static class CommandEvent extends Event {
        /** The AT command that generated the event. */
        public CodelessCommand command;

        public CommandEvent(CodelessCommand command) {
            super(command.getManager());
            this.command = command;
        }
    }

    /** Event generated when the sent AT command completes successfully. */
    public static class CommandSuccess extends CommandEvent {
        public CommandSuccess(CodelessCommand command) {
            super(command);
        }
    }

    /** Event generated when the sent AT command fails. */
    public static class CommandError extends CommandEvent {
        /** The error message describing the failure. */
        public String msg;

        public CommandError(CodelessCommand command, String msg) {
            super(command);
            this.msg = msg;
        }
    }

    /** Event generated after <code>AT+</code> command completes successfully. */
    public static class Ping extends CommandEvent {
        public Ping(BasicCommand command) {
            super(command);
        }
    }

    /** Event generated after <code>AT+I</code> command completes successfully. */
    public static class DeviceInformation extends CommandEvent {
        /** The received device information text. */
        public String info;

        public DeviceInformation(DeviceInformationCommand command) {
            super(command);
            info = command.getInfo();
        }
    }

    /** Event generated after <code>AT+E</code> command completes successfully. */
    public static class UartEcho extends CommandEvent {
        /** <code>true</code> if UART echo is on, <code>false</code> if it is off. */
        public boolean echo;

        public UartEcho(UartEchoCommand command) {
            super(command);
            echo = command.echo();
        }
    }

    /** Event generated after <code>AT+BINESC</code> command completes successfully. */
    public static class BinEsc extends CommandEvent {
        /** The 3-byte escape sequence as a 24-bit value. */
        public int sequence;
        /** The idle time before the escape sequence (ms). */
        public int timePrior;
        /** The idle time after the escape sequence (ms). */
        public int timeAfter;

        public BinEsc(BinEscCommand command) {
            super(command);
            this.sequence = command.getSequence();
            this.timePrior = command.getTimePrior();
            this.timeAfter = command.getTimeAfter();
        }
    }

    /** Event generated after <code>AT+RANDOM</code> command completes successfully. */
    public static class RandomNumber extends CommandEvent {
        /** The random number (unsigned 32-bit). */
        public long number;

        public RandomNumber(RandomNumberCommand command) {
            super(command);
            number = command.getNumber();
        }
    }

    /** Event generated after <code>AT+BATT</code> command completes successfully. */
    public static class BatteryLevel extends CommandEvent {
        /** The battery level (percentage). */
        public int level;

        public BatteryLevel(BatteryLevelCommand command) {
            super(command);
            level = command.getLevel();
        }
    }

    /** Event generated after <code>AT+BDADDR</code> command completes successfully. */
    public static class BluetoothAddress extends CommandEvent {
        /** The peer device Bluetooth address. */
        public String address;
        /** <code>true</code> if the Bluetooth address is random, <code>false</code> if it is public. */
        public boolean random;

        public BluetoothAddress(BluetoothAddressCommand command) {
            super(command);
            address = command.getAddress();
            random = command.isRandom();
        }
    }

    /** Event generated after <code>AT+RSSI</code> command completes successfully. */
    public static class PeerRssi extends CommandEvent {
        /** The connection RSSI measured by the peer device. */
        public int rssi;

        public PeerRssi(RssiCommand command) {
            super(command);
            rssi = command.getRssi();
        }
    }

    /** Event generated after <code>AT+IOCFG</code> command without parameters completes successfully. */
    public static class IoConfig extends CommandEvent {
        /** The current IO pin configuration. */
        public ArrayList<CodelessProfile.GPIO> configuration;

        public IoConfig(IoConfigCommand command) {
            super(command);
            configuration = command.getConfiguration();
        }
    }

    /** Event generated after <code>AT+IOCFG</code> command with parameters completes successfully. */
    public static class IoConfigSet extends CommandEvent {
        /** The IO pin that was configured. */
        public CodelessProfile.GPIO gpio;

        public IoConfigSet(IoConfigCommand command) {
            super(command);
            gpio = command.getGpio();
        }
    }

    /** Event generated after <code>AT+IO</code> command completes successfully. */
    public static class IoStatus extends CommandEvent {
        /** The selected IO pin. */
        public CodelessProfile.GPIO gpio;
        /** <code>true</code> if status is high, <code>false</code> if it is low. */
        public boolean status;

        public IoStatus(IoStatusCommand command) {
            super(command);
            gpio = command.getGpio();
            status = command.getStatus();
        }
    }

    /** Event generated after <code>AT+ADC</code> command completes successfully. */
    public static class AnalogRead extends CommandEvent {
        /** The selected analog input pin. */
        public CodelessProfile.GPIO gpio;
        /** The analog pin state. */
        public int state;

        public AnalogRead(AdcReadCommand command) {
            super(command);
            gpio = command.getGpio();
            state = command.getState();
        }
    }

    /** Event generated after <code>AT+PWM</code> command without parameters completes successfully. */
    public static class PwmStatus extends CommandEvent {
        /** The frequency of the pulse in Hz. */
        public int frequency;
        /** The duty cycle of the pulse. */
        public int dutyCycle;
        /** The duration of the pulse in ms. */
        public int duration;

        public PwmStatus(PulseGenerationCommand command) {
            super(command);
            frequency = command.getFrequency();
            dutyCycle = command.getDutyCycle();
            duration = command.getDuration();
        }
    }

    /** Event generated after <code>AT+PWM</code> command with parameters completes successfully. */
    public static class PwmStart extends CommandEvent {
        /** The frequency of the pulse in Hz. */
        public int frequency;
        /** The duty cycle of the pulse. */
        public int dutyCycle;
        /** The duration of the pulse in ms. */
        public int duration;

        public PwmStart(PulseGenerationCommand command) {
            super(command);
            frequency = command.getFrequency();
            dutyCycle = command.getDutyCycle();
            duration = command.getDuration();
        }
    }

    /** Event generated after <code>AT+I2CCFG</code> command completes successfully. */
    public static class I2cConfig extends CommandEvent {
        /** The I2C address bit-count. */
        public int addressSize;
        /** The I2C bus bitrate in KHz. */
        public int bitrate;
        /** The I2C register bit-count. */
        public int registerSize;

        public I2cConfig(I2cConfigCommand command) {
            super(command);
            addressSize = command.getBitCount();
            bitrate = command.getBitRate();
            registerSize = command.getRegisterWidth();
        }
    }

    /** Event generated after <code>AT+I2CSCAN</code> command completes successfully. */
    public static class I2cScan extends CommandEvent {
        /** The list of the {@link I2cScanCommand.I2cDevice devices} found on the I2C bus. */
        public ArrayList<I2cScanCommand.I2cDevice> devices;

        public I2cScan(I2cScanCommand command) {
            super(command);
            devices = command.getDevices();
        }
    }

    /** Event generated after <code>AT+I2CREAD</code> command completes successfully. */
    public static class I2cRead extends CommandEvent {
        /** The read data byte array. */
        public int[] data;

        public I2cRead(I2cReadCommand command) {
            super(command);
            data = command.getData();
        }
    }

    /** Event generated after <code>AT+MEM</code> command completes successfully. */
    public static class MemoryTextContent extends CommandEvent {
        /** The memory slot index (0-3). */
        public int index;
        /** The stored text. */
        public String text;

        public MemoryTextContent(MemStoreCommand command) {
            super(command);
            index = command.getMemIndex();
            text = command.getText();
        }
    }

    /** Event generated after <code>AT+PIN</code> command completes successfully. */
    public static class PinCode extends CommandEvent {
        /** The pin code. */
        public int pinCode;

        public PinCode(PinCodeCommand command) {
            super(command);
            pinCode = command.getPinCode();
        }
    }

    /** Event generated after <code>AT+CMD</code> command completes successfully. */
    public static class StoredCommands extends CommandEvent {
        /** The command slot index (0-3). */
        public int index;
        /** The stored commands. */
        public ArrayList<CodelessCommand> commands;

        public StoredCommands(CmdGetCommand command) {
            super(command);
            index = command.getIndex();
            commands = command.getCommands();
        }
    }

    /** Event generated after <code>AT+ADVDATA</code> command completes successfully. */
    public static class AdvertisingData extends CommandEvent {
        /** The advertising data byte array. */
        public byte[] data;

        public AdvertisingData(AdvertisingDataCommand command) {
            super(command);
            data = command.getData();
        }
    }

    /** Event generated after <code>AT+ADVRESP</code> command completes successfully. */
    public static class ScanResponseData extends CommandEvent {
        /** The scan response data byte array. */
        public byte[] data;

        public ScanResponseData(AdvertisingResponseCommand command) {
            super(command);
            data = command.getData();
        }
    }

    /** Event generated after <code>AT+GAPSTATUS</code> command completes successfully. */
    public static class GapStatus extends CommandEvent {
        /** The GAP role (0: peripheral, 1: central). */
        public int gapRole;
        /** <code>true</code> if connected, <code>false</code> if disconnected. */
        public boolean connected;

        public GapStatus(GapStatusCommand command) {
            super(command);
            gapRole = command.getGapRole();
            connected = command.connected();
        }
    }

    /** Event generated after <code>AT+GAPSCAN</code> command completes successfully. */
    public static class GapScanResult extends CommandEvent {
        /** The {@link CodelessProfile.GapScannedDevice devices} that were found during the scan. */
        public ArrayList<CodelessProfile.GapScannedDevice> devices;

        public GapScanResult(GapScanCommand command) {
            super(command);
            devices = command.getDevices();
        }
    }

    /** Event generated after <code>AT+GAPCONNECT</code> command completes successfully. */
    public static class DeviceConnected extends CommandEvent {
        /** The Bluetooth address of the connected device. */
        public String deviceAddress;

        public DeviceConnected(GapConnectCommand command) {
            super(command);
            deviceAddress = command.getAddress();
        }
    }

    /** Event generated after <code>AT+GAPDISCONNECT</code> command completes successfully. */
    public static class DeviceDisconnected extends CommandEvent {
        public DeviceDisconnected(GapDisconnectCommand command) {
            super(command);
        }
    }

    /** Event generated after <code>AT+CONPAR</code> command completes successfully. */
    public static class ConnectionParameters extends CommandEvent {
        /** The connection interval in multiples of 1.25 ms. */
        public int interval;
        /** The slave latency. */
        public int latency;
        /** The supervision timeout in multiples of 10 ms. */
        public int timeout;
        /** Specifies how the connection parameters are applied. */
        public int action;

        public ConnectionParameters(ConnectionParametersCommand command) {
            super(command);
            interval = command.getInterval();
            latency = command.getLatency();
            timeout = command.getTimeout();
            action = command.getAction();
        }
    }

    /** Event generated after <code>AT+MAXMTU</code> command completes successfully. */
    public static class MaxMtu extends CommandEvent {
        /** The maximum MTU value. */
        public int mtu;

        public MaxMtu(MaxMtuCommand command) {
            super(command);
            mtu = command.getMtu();
        }
    }

    /** Event generated after <code>AT+FLOWCONTROL</code> command completes successfully. */
    public static class FlowControl extends CommandEvent {
        /** <code>true</code> if UART RTS/CTS flow control is enabled, <code>false</code> if it is disabled. */
        public boolean enabled;
        /** {@link CodelessProfile.GPIO GPIO} pin for the RTS signal. */
        public CodelessProfile.GPIO rtsGpio;
        /** {@link CodelessProfile.GPIO GPIO} pin for the CTS signal. */
        public CodelessProfile.GPIO ctsGpio;

        public FlowControl(FlowControlCommand command) {
            super(command);
            enabled = command.isEnabled();
            rtsGpio = command.getRtsGpio();
            ctsGpio = command.getCtsGpio();
        }
    }

    /** Event generated after <code>AT+HOSTSLP</code> command completes successfully. */
    public static class HostSleep extends CommandEvent {
        /** The host sleep mode. */
        public int hostSleepMode;
        /** The byte value to use in order to wake up the host. */
        public int wakeupByte;
        /** The interval between wakeup retries (ms). */
        public int wakeupRetryInterval;
        /** The number of wakeup retries. */
        public int wakeupRetryTimes;

        public HostSleep(HostSleepCommand command) {
            super(command);
            hostSleepMode = command.getHostSleepMode();
            wakeupByte = command.getWakeupByte();
            wakeupRetryInterval = command.getWakeupRetryInterval();
            wakeupRetryTimes = command.getWakeupRetryTimes();
        }
    }

    /** Event generated after <code>AT+SPICFG</code> command completes successfully. */
    public static class SpiConfig extends CommandEvent {
        /** The SPI clock value (0: 2 MHz, 1: 4 MHz, 2: 8 MHz). */
        public int speed;
        /** The SPI mode (clock polarity and phase). */
        public int mode;
        /** The SPI word bit-count. */
        public int size;

        public SpiConfig(SpiConfigCommand command) {
            super(command);
            speed = command.getSpeed();
            mode = command.getMode();
            size = command.getSize();
        }
    }

    /** Event generated after <code>AT+SPIRD</code> command completes successfully. */
    public static class SpiRead extends CommandEvent {
        /** The read data byte array. */
        public int[] data;

        public SpiRead(SpiReadCommand command) {
            super(command);
            data = command.getData();
        }
    }

    /** Event generated after <code>AT+SPITR</code> command completes successfully. */
    public static class SpiTransfer extends CommandEvent {
        /** The read data byte array. */
        public int[] data;

        public SpiTransfer(SpiTransferCommand command) {
            super(command);
            data = command.getData();
        }
    }

    /** Event generated after <code>AT+BAUD</code> command completes successfully. */
    public static class BaudRate extends CommandEvent {
        /** The UART baud rate. */
        public int baudRate;

        public BaudRate(BaudRateCommand command) {
            super(command);
            baudRate = command.getBaudRate();
        }
    }

    /** Event generated after <code>AT+DLEEN</code> command completes successfully. */
    public static class DataLengthEnable extends CommandEvent {
        /** <code>true</code> if DLE is enabled, <code>false</code> if it is disabled. */
        public boolean enabled;
        /** The DLE TX packet length. */
        public int txPacketLength;
        /** The DLE RX packet length. */
        public int rxPacketLength;

        public DataLengthEnable(DataLengthEnableCommand command) {
            super(command);
            enabled = command.enabled();
            txPacketLength = command.getTxPacketLength();
            rxPacketLength = command.getRxPacketLength();
        }
    }

    /** Event generated after <code>AT+EVENT</code> command with parameters completes successfully. */
    public static class EventStatus extends CommandEvent {
        /** The event configuration that was set. */
        public CodelessProfile.EventConfig eventConfig;

        public EventStatus(EventConfigCommand command) {
            super(command);
            eventConfig = command.getEventConfig();
        }
    }

    /** Event generated after <code>AT+EVENT</code> command without parameters completes successfully. */
    public static class EventStatusTable extends CommandEvent {
        /** The current event configuration. */
        public ArrayList<CodelessProfile.EventConfig> eventStatusTable;

        public EventStatusTable(EventConfigCommand command) {
            super(command);
            eventStatusTable = command.getEventStatusTable();
        }
    }

    /** Event generated after <code>AT+CLRBNDE</code> command completes successfully. */
    public static class BondingEntryClear extends CommandEvent {
        /** The bonding entry that was cleared (1-5, 0xFF: all entries). */
        public int index;

        public BondingEntryClear(BondingEntryClearCommand command) {
            super(command);
            index = command.getIndex();
        }
    }

    /** Event generated after <code>AT+CHGBNDP</code> command with parameters completes successfully. */
    public static class BondingEntryPersistenceStatusSet extends CommandEvent {
        /** The bonding entry (1-5, 0xFF: all entries). */
        public int index;
        /** <code>true</code> if persistence is enabled, <code>false</code> if it is disabled. */
        public boolean persistent;

        public BondingEntryPersistenceStatusSet(BondingEntryStatusCommand command) {
            super(command);
            index = command.getIndex();
            persistent = command.persistent();
        }
    }

    /** Event generated after <code>AT+CHGBNDP</code> command without parameters completes successfully. */
    public static class BondingEntryPersistenceTableStatus extends CommandEvent {
        /** One Boolean value per bonding entry: <code>true</code> if persistence is enabled, <code>false</code> if it is disabled, <code>null</code> if entry is unused. */
        public ArrayList<Boolean> persistenceStatusTable;

        public BondingEntryPersistenceTableStatus(BondingEntryStatusCommand command) {
            super(command);
            persistenceStatusTable = command.getTablePersistenceStatus();
        }
    }

    /** Event generated after <code>AT+IEBNDE</code> command completes successfully. */
    public static class BondingEntryEvent extends CommandEvent {
        /** The bonding entry (1-5). */
        public int index;
        /** The bonding entry {@link CodelessProfile.BondingEntry configuration}. */
        public CodelessProfile.BondingEntry entry;

        public BondingEntryEvent(BondingEntryTransferCommand command) {
            super(command);
            index = command.getIndex();
            entry = command.getBondingEntry();
        }
    }

    /**
     * Event generated when a {@link CodelessLibConfig#supportedCommands supported} incoming CodeLess command is received from the peer device.
     * <p> The library provides a default implementation with an appropriate response.
     */
    public static class InboundCommand extends CommandEvent {
        public InboundCommand(CodelessCommand command) {
            super(command);
        }
    }

    /**
     * Event generated when an incoming CodeLess command, that is configured to be processed by the app, is received from the peer device.
     * <p> The app is responsible for sending a proper response.
     * @see CodelessLibConfig#hostCommands
     * @see CodelessLibConfig#HOST_UNSUPPORTED_COMMANDS
     * @see CodelessLibConfig#HOST_INVALID_COMMANDS
     */
    public static class HostCommand extends CommandEvent {
        public HostCommand(CodelessCommand command) {
            super(command);
        }
    }

    /** Event generated when an incoming <code>AT+PRINT</code> command is received from the peer device. */
    public static class Print extends CommandEvent {
        /** The text argument of the command. */
        public String text;

        public Print(UartPrintCommand command) {
            super(command);
            this.text = command.getText();
        }
    }

    /** Event generated after <code>AT+HNDL</code> command with parameters completes successfully. */
    public static class EventCommands extends CommandEvent {
        /** The event handler that was set. */
        public CodelessProfile.EventHandler eventHandler;

        public EventCommands(EventHandlerCommand command) {
            super(command);
            eventHandler = command.getEventHandler();
        }
    }

    /** Event generated after <code>AT+HNDL</code> command without parameters completes successfully. */
    public static class EventCommandsTable extends CommandEvent {
        /** The current event handlers configuration. */
        public ArrayList<CodelessProfile.EventHandler> eventHandlerTable;

        public EventCommandsTable(EventHandlerCommand command) {
            super(command);
            eventHandlerTable = command.getEventHandlerTable();
        }
    }

    /** Event generated after <code>AT+SEC</code> command completes successfully. */
    public static class SecurityMode extends CommandEvent {
        /** The security {@link CodelessProfile.Command#SECURITY_MODE_0 mode} to use. */
        public int mode;

        public SecurityMode(SecurityModeCommand command) {
            super(command);
            mode = command.getMode();
        }
    }

    /** Event generated after <code>AT+HRTBT</code> command completes successfully. */
    public static class Heartbeat extends CommandEvent {
        /** <code>true</code> if heartbeat signal is enabled, <code>false</code> if it is disabled. */
        public boolean enabled;

        public Heartbeat(HeartbeatCommand command) {
            super(command);
            enabled = command.enabled();
        }
    }

    /** Event generated after <code>AT+PWRLVL</code> command completes successfully. */
    public static class PowerLevel extends CommandEvent {
        /** The Bluetooth output power level {@link CodelessProfile.Command#OUTPUT_POWER_LEVEL_MINUS_19_POINT_5_DBM index}. */
        public int powerLevel;
        /** <code>true</code> if power level configuration is not supported by the peer device. */
        public boolean notSupported;

        public PowerLevel(PowerLevelConfigCommand command) {
            super(command);
            powerLevel = command.getPowerLevel();
            notSupported = command.notSupported();
        }
    }

    /** Event generated when binary data are received from the peer DSPS device. */
    public static class DspsRxData extends Event {
        /** The data that were received. */
        public byte[] data;

        public DspsRxData(CodelessManager manager, byte[] data) {
            super(manager);
            this.data = data;
        }
    }

    /** Event generated when a DSPS RX flow control message is sent to the peer device. */
    public static class DspsRxFlowControl extends Event {
        /** <code>true</code>, if RX flow is on, <code>false</code> if it is off. */
        public boolean flowOn;

        public DspsRxFlowControl(CodelessManager manager, boolean flowOn) {
            super(manager);
            this.flowOn = flowOn;
        }
    }

    /** Event generated when a DSPS TX flow control message is received from the peer device. */
    public static class DspsTxFlowControl extends Event {
        /** <code>true</code>, if TX flow is on, <code>false</code> if it is off. */
        public boolean flowOn;

        public DspsTxFlowControl(CodelessManager manager, boolean flowOn) {
            super(manager);
            this.flowOn = flowOn;
        }
    }

    /** Event generated when a file chunk is sent to the peer DSPS device, as part of a file send operation. */
    public static class DspsFileChunk extends Event {
        /** The DSPS file send operation that contains the file chunk. */
        public DspsFileSend operation;
        /** The file chunk number. */
        public int chunk;

        public DspsFileChunk(CodelessManager manager, DspsFileSend operation, int chunk) {
            super(manager);
            this.operation = operation;
            this.chunk = chunk;
        }
    }

    /** Event generated when the selected file for a DSPS file send operation cannot be loaded. */
    public static class DspsFileError extends Event {
        /** The DSPS file send operation. */
        public DspsFileSend operation;

        public DspsFileError(CodelessManager manager, DspsFileSend operation) {
            super(manager);
            this.operation = operation;
        }
    }

    /** Event generated when a file chunk is received from the peer DSPS device, as part of a file receive operation. */
    public static class DspsRxFileData extends Event {
        /** The DSPS file receive operation that contains the file chunk. */
        public DspsFileReceive operation;
        /** The total number of bytes. */
        public int size;
        /** The number of bytes that have been received. */
        public int bytesReceived;

        public DspsRxFileData(CodelessManager manager, DspsFileReceive operation, int size, int bytesReceived) {
            super(manager);
            this.operation = operation;
            this.size = size;
            this.bytesReceived = bytesReceived;
        }
    }

    /** Event generated when a DSPS file receive operation with CRC is complete. */
    public static class DspsRxFileCrc extends Event {
        /** The DSPS file receive operation. */
        public DspsFileReceive operation;
        /** <code>true</code> if the CRC check succeeded, <code>false</code> if it failed. */
        public boolean ok;

        public DspsRxFileCrc(CodelessManager manager, DspsFileReceive operation, boolean ok) {
            super(manager);
            this.operation = operation;
            this.ok = ok;
        }
    }

    /** Event generated when a chunk is sent to the peer DSPS device, as part of a pattern send operation. */
    public static class DspsPatternChunk extends Event {
        /** The DSPS pattern send operation. */
        public DspsPeriodicSend operation;
        /** The pattern chunk number. */
        public int count;

        public DspsPatternChunk(CodelessManager manager, DspsPeriodicSend operation, int count) {
            super(manager);
            this.operation = operation;
            this.count = count;
        }
    }

    /** Event generated when the selected file for a DSPS pattern send operation cannot be loaded. */
    public static class DspsPatternFileError extends Event {
        /** The DSPS pattern send operation. */
        public DspsPeriodicSend operation;
        /** The selected file, if a File was used to load the pattern. */
        public File file;
        /** The selected file URI, if a URI was used to load the pattern.. */
        public Uri uri;

        public DspsPatternFileError(CodelessManager manager, DspsPeriodicSend operation, File file, Uri uri) {
            super(manager);
            this.operation = operation;
            this.file = file;
            this.uri = uri;
        }
    }

    /**
     * Event generated when DSPS statistics are calculated.
     * <p> Statistics are calculated only if {@link CodelessLibConfig#DSPS_STATS} is enabled.
     */
    public static class DspsStats extends Event {
        /** The DSPS operation for which the statistics are calculated (file send/receive, pattern send or <code>null</code> for global statistics). */
        public Object operation;
        /** The calculated send (for file/pattern send) or receive (for global or file receive) speed. */
        public int currentSpeed;
        /** The calculated average send/receive speed for the duration of the DSPS operation (invalid for global). */
        public int averageSpeed;

        public DspsStats(CodelessManager manager, Object operation, int currentSpeed, int averageSpeed) {
            super(manager);
            this.operation = operation;
            this.currentSpeed = currentSpeed;
            this.averageSpeed = averageSpeed;
        }
    }
}
